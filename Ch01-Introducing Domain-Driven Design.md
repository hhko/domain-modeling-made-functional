# Introducing Domain-Driven Design

개발자라면 자신의 일이 코드를 작성하는 것이라고 생각하기 쉽습니다.

하지만 저는 그렇게 보지 않습니다.

개발자의 본질적인 역할은 소프트웨어를 통해 문제를 해결하는 것이며, 코딩은 그 과정의 한 부분일 뿐입니다.

탄탄한 설계와 원활한 커뮤니케이션은 때로는 코딩보다 더 중요한 요소가 되기도 합니다.

소프트웨어 개발을 입력(요구사항)과 출력(최종 산출물)이 있는 파이프라인이라고 생각해 봅시다. 이때 흔히 말하는 "Garbage in, garbage out"(쓰레기가 들어가면 쓰레기가 나온다) 원칙이 그대로 적용됩니다.

요구사항이 불명확하거나 설계가 부실하다면, 아무리 뛰어난 코드를 작성하더라도 좋은 결과물을 만들 수 없습니다.

이 책의 1부에서는, 부실한 입력을 최소화하기 위해 명확한 의사소통과 공유된 도메인 지식을 중심에 둔 설계 접근법인 도메인 주도 설계(DDD, Domain-Driven Design)를 다룰 것입니다.

이 장에서는 먼저 DDD의 기본 원칙을 살펴보고, 그 원칙이 하나의 구체적인 도메인에 어떻게 적용될 수 있는지 보여줄 예정입니다.

DDD는 매우 방대한 주제이기 때문에 이 책에서는 모든 내용을 깊이 다루지는 않을 것입니다. (더 자세한 내용이 궁금하다면 dddcommunity.org¹에서 참고할 수 있습니다.)

하지만 이 장을 읽고 나면, 여러분은 도메인 주도 설계가 어떻게 작동하는지, 그리고 그것이 데이터베이스 중심 설계나 객체 지향 설계와 어떻게 다른지에 대해 명확한 그림을 그릴 수 있을 것입니다.

물론 도메인 주도 설계가 모든 소프트웨어 개발에 적합한 것은 아닙니다.

시스템 소프트웨어, 게임 등과 같이 DDD가 아닌 다른 접근법으로도 충분히 구축할 수 있는 많은 종류의 소프트웨어가 존재합니다.

그러나 비즈니스 및 엔터프라이즈 소프트웨어처럼 비기술 부서와 협업해야 하는 환경에서는 DDD가 특히 유용하며, 이 책은 바로 이러한 종류의 소프트웨어를 중심으로 이야기를 풀어갈 것입니다.

## The Importance of a Shared Model 공유 모델의 중요성

어떤 문제를 해결하기에 앞서, 우리는 그 문제를 올바르게 이해하고 있는지부터 확인해야 합니다.

문제를 불완전하게 이해하거나 왜곡된 상태로 이해하고 있다면, 당연히 유용한 해결책을 제시할 수 없습니다.

그리고 안타깝게도 현실에서는, 도메인 전문가의 이해가 아니라 개발자의 이해가 그대로 제품에 반영되어 출시됩니다.

> 그렇다면 개발자인 우리가 문제를 제대로 이해하고 있다는 것을 어떻게 보장할 수 있을까요?

일부 소프트웨어 개발 프로세스에서는 이를 해결하기 위해 문서화된 명세서나 요구사항 문서를 작성하여 문제의 모든 세부 사항을 기록하려고 시도합니다.

하지만 이런 접근법은 종종 문제를 가장 잘 이해하고 있는 사람과 해결책을 실제로 구현할 사람 사이에 거리감을 만들곤 합니다.

여기서 우리는 문제를 실제로 구현하는 사람들을 통칭해 '개발팀'이라 부르겠습니다. 이 개발팀에는 개발자뿐 아니라 UX·UI 디자이너, 테스터 등도 포함됩니다.

반대로 문제를 가장 잘 이해하고 있는 사람들을 '도메인 전문가'라고 부르겠습니다.

'도메인 전문가'의 정확한 정의를 굳이 내릴 필요는 없습니다. 직접 만나 보면 바로 알 수 있을 테니까요.

어린이들이 하는 '전달 게임(Telephone)'이라는 놀이가 있습니다. 한 아이가 옆 사람에게 귓속말로 어떤 말을 전하고, 그 아이는 다시 옆 사람에게 같은 말을 전합니다.

이 과정을 여러 번 반복하다 보면, 처음 메시지가 점점 왜곡되어 우스꽝스러운 내용으로 바뀌게 됩니다.

하지만 현실의 소프트웨어 개발 프로젝트에서는 이런 일이 결코 웃기지 않습니다.

개발자가 이해한 문제와 도메인 전문가가 이해한 문제가 불일치할 경우, 그것은 프로젝트 성공에 치명적일 수 있습니다.

이를 방지하는 가장 좋은 방법은 중간 전달자를 없애고, 도메인 전문가를 개발 과정에 밀접하게 참여시키는 것입니다. 개발팀과 도메인 전문가 사이에 지속적인 피드백 루프를 만들어야 합니다.

개발팀이 일정 주기로 결과물을 전달하면, 도메인 전문가가 오해된 부분을 빠르게 교정해 다음 반복 주기에서 반영할 수 있습니다.

이런 반복적인 개발 과정은 '애자일(agile)' 개발 방식의 핵심입니다.

그러나 이 접근법에도 한 가지 근본적인 문제가 있습니다.

바로 개발자가 '번역가' 역할을 해야 한다는 점입니다. 개발자는 도메인 전문가의 머릿속에 있는 개념적 모델을 코드로 번역해야 합니다.

모든 번역이 그렇듯 이 과정에서도 왜곡이 생기고 중요한 뉘앙스가 손실될 위험이 있습니다.

코드가 도메인의 개념을 제대로 반영하지 못한다면, 나중에 도메인 전문가의 도움 없이 코드베이스를 유지·보수하는 개발자들이 요구사항을 오해하고 오류를 만들어낼 가능성이 높아집니다.

하지만 세 번째 방법이 있습니다.

만약 도메인 전문가, 개발팀, 기타 이해관계자들, 그리고 (무엇보다도) 소스코드 자체가 모두 같은 모델을 공유한다면 어떨까요?

이 경우에는 도메인 전문가의 요구사항을 코드로 '번역'하는 과정 자체가 필요 없습니다.

코드가 곧바로 그 '공유된 정신적 모델'을 반영하도록 설계되는 것입니다.

그리고 이것이 바로 도메인 주도 설계(DDD)의 궁극적인 목표입니다.

소프트웨어 모델을 비즈니스 도메인과 일치시키면 여러 가지 이점이 있습니다.

- 시장 출시 속도 향상 --- 개발자와 코드베이스가 문제를 가진 사람과 동일한 모델을 공유하면, 팀은 더 빠르게 적절한 해결책을 개발할 가능성이 높아집니다.
- 더 높은 비즈니스 가치 --- 문제에 정확히 부합하는 해결책은 고객 만족도를 높이고, 방향을 잘못 잡을 가능성을 줄여줍니다.
- 낭비 감소 --- 요구사항이 명확해지면 오해나 재작업으로 낭비되는 시간이 줄어듭니다. 또한 이러한 명확성은 어떤 구성 요소가 더 높은 가치를 가지는지 파악하게 해주어, 개발 노력을 가치 높은 부분에 집중하고 가치가 낮은 부분에는 적게 투자할 수 있게 합니다.
- 더 쉬운 유지보수와 진화 --- 코드가 표현하는 모델이 도메인 전문가의 모델과 밀접하게 일치하면, 코드를 변경하기가 더 쉽고 오류 발생 가능성도 줄어듭니다. 또한 새로운 팀원이 더 빨리 적응할 수 있습니다.

> ### The Insanely Effective Delivery Machine 믿을 수 없을 만큼 효과적인 딜리버리 머신
> - 행위 주도 개발(Behavior-Driven Development, BDD)로 유명한 개발자이자 전도사인 댄 노스(Dan North)는, 자신의 강연 「Accelerating Agile」에서 공유된 정신적 모델을 경험한 이야기를 들려주었습니다.
> - 그는 한 증권회사의 소규모 팀에 합류했는데, 그곳을 자신이 경험한 팀 중 가장 믿기 힘들 정도로 효율적인 '딜리버리 머신'이었다고 묘사했습니다.
> - 그 회사에서는 소수의 개발자들이 수개월이나 수년이 아닌 단 몇 주 만에 최첨단 거래 시스템을 만들어냈습니다.
> - 이 팀이 성공할 수 있었던 이유 중 하나는, 개발자들이 실제 트레이더들과 함께 트레이딩 교육을 받았기 때문입니다.
> - 즉, 그들은 스스로 도메인 전문가가 된 것입니다.
> - 이 덕분에 그들은 공유된 정신적 모델을 기반으로 트레이더들과 매우 효과적으로 소통할 수 있었고, 도메인 전문가(트레이더)들이 원하는 것을 정확히 만들어낼 수 있었습니다.

따라서 우리는 공유 모델을 만들어야 합니다.

그렇다면 어떻게 해야 할까요?

도메인 주도 설계(DDD) 커뮤니티에서는 이를 돕기 위한 몇 가지 지침을 마련해두었습니다.

그 지침은 다음과 같습니다.

- 데이터 구조보다는 비즈니스 이벤트와 워크플로에 집중하라.
- 문제 도메인을 더 작은 하위 도메인들로 분할하라.
- 해결책 안에 각 하위 도메인의 모델을 만들어라.
- 프로젝트에 참여하는 모든 사람이 공유하며 코드 전반에 걸쳐 사용하는 공통 언어(유비쿼터스 언어)를 개발하라.

이제 이 지침들을 하나씩 살펴보겠습니다.

## Understanding the Domain Through Business Events 비즈니스 이벤트를 통해 도메인을 이해하기

DDD 접근법은 요구사항을 수집할 때, 개발자와 도메인 전문가 사이의 공유된 이해를 구축하는 데 중점을 둡니다.

그렇다면 이런 이해를 쌓기 위해 어디서부터 시작해야 할까요?

첫 번째 지침은 데이터 구조가 아닌 비즈니스 이벤트에 집중하라는 것입니다.

왜 그럴까요?

비즈니스는 단순히 데이터를 보유하는 것이 아니라, 어떤 방식으로든 그것을 변환합니다.

즉, 전형적인 비즈니스 프로세스는 일련의 데이터 또는 문서 변환 과정이라고 볼 수 있습니다.

비즈니스의 가치는 이러한 변환 과정에서 창출되므로, 이 변환이 어떻게 작동하고 서로 어떤 관계가 있는지를 이해하는 것이 매우 중요합니다.

그냥 가만히 존재하는 정적인 데이터는 아무런 가치도 만들어내지 못합니다.

그렇다면 무엇이 직원(또는 자동화된 프로세스)으로 하여금 그 데이터를 사용하고 가치를 더하게 만드는 걸까요?

종종 외부에서 오는 트리거(메일 도착, 전화벨 울림)일 수 있고, 시간 기반의 트리거(매일 오전 10시에 하는 작업)일 수도 있으며, 상황 관찰(처리할 주문이 더 이상 없으니 다른 일을 한다)일 수도 있습니다.

무엇이든 간에, 그것을 설계의 일부로 포착하는 것이 중요합니다.

이런 것들을 우리는 도메인 이벤트(Domain Events)라고 부릅니다.

도메인 이벤트는 우리가 모델링하고자 하는 거의 모든 비즈니스 프로세스의 출발점입니다.

예를 들어, "새 주문서가 접수됨"은 주문 접수 프로세스를 시작하게 만드는 도메인 이벤트입니다.

도메인 이벤트는 항상 과거 시제로 작성됩니다. 무언가가 이미 일어난 사실이며, 바꿀 수 없는 것이기 때문입니다.

### Using Event Storming to Discover the Domain 이벤트 스토밍으로 도메인을 발견하기

도메인에서 이벤트를 찾아내는 방법은 여러 가지가 있지만, DDD 접근법에 특히 잘 맞는 방법은 이벤트 스토밍(Event Storming)입니다. 이벤트 스토밍은 비즈니스 이벤트와 그에 연관된 워크플로를 공동으로 탐색하는 협업 프로세스입니다.

이벤트 스토밍에서는 도메인의 서로 다른 부분을 이해하고 있는 여러 사람들을 한자리에 모아 워크숍을 진행합니다.

참석자에는 개발자와 도메인 전문가뿐만 아니라, 프로젝트 성공에 관심 있는 모든 이해관계자가 포함되어야 합니다. 이벤트 스토밍 실무자들이 말하듯이, "질문이 있는 사람과 답을 아는 사람이라면 누구나" 참석해야 합니다.

워크숍은 벽면 공간이 넓은 방에서 진행해야 하며, 벽에는 종이나 화이트보드 재질을 붙여 참가자들이 포스트잇을 붙이거나 자유롭게 그림을 그릴 수 있어야 합니다.

성공적인 세션이 끝나면 벽면이 수백 장의 포스트잇으로 뒤덮이게 됩니다.

워크숍 동안 참가자들은 포스트잇에 비즈니스 이벤트를 적어 벽에 붙입니다.

다른 참가자들은 해당 이벤트에 의해 촉발되는 비즈니스 워크플로를 요약해 포스트잇으로 붙이며 반응할 수 있습니다.

이러한 워크플로는 다시 새로운 비즈니스 이벤트를 만들어내곤 합니다.

또한 포스트잇들은 종종 타임라인 순서대로 정리될 수 있으며, 이는 그룹 내에서 추가 논의를 유도하기도 합니다.

이 과정의 핵심은 참가자 모두가 자신이 아는 것을 게시하고, 모르는 것에 대해 질문하도록 참여시키는 것입니다.

이것은 모두의 참여를 이끄는 매우 상호작용적인 프로세스입니다.

이벤트 스토밍의 실제 적용에 대한 더 자세한 내용은 이 기법을 창안한 알베르토 브란돌리니(Alberto Brandolini)의 저서 『EventStorming』²을 참고하세요.

### Discovering the Domain: An Order-Taking System 도메인 발견하기: 주문 접수 시스템

이 책에서는 실제적인 비즈니스 문제인 주문 접수 시스템을 예로 들어, 설계와 도메인 모델링, 구현을 살펴볼 것입니다.

예를 들어, 우리에게 소규모 제조업체인 위젯츠(Widgets) 사의 주문 접수 업무 흐름을 자동화해 달라는 요청이 들어왔다고 가정해 봅시다.

위젯츠의 매니저인 맥스(Max)가 이렇게 설명합니다.

> "우리는 다른 회사에 부품을 납품하는 아주 작은 제조업체입니다. 위젯, 기즈모 같은 것들을 만들죠. 최근 빠르게 성장하고 있는데, 기존의 프로세스로는 그 속도를 따라가지 못하고 있어요. 지금은 모든 업무가 종이로 이루어져 있어서, 이를 전산화해 직원들이 더 많은 주문을 처리할 수 있도록 하고 싶습니다. 특히 고객들이 직접 일부 업무를 처리할 수 있는 셀프 서비스 웹사이트를 구축하고 싶습니다. 예를 들어 주문을 넣거나 주문 상태를 확인하는 등의 작업 말이죠."

좋습니다. 그렇다면 이제 우리는 무엇을 해야 할까요? 어디서부터 시작해야 할까요?

첫 번째 지침이 '비즈니스 이벤트에 집중하라'이므로, 이벤트 스토밍 세션을 활용해 보겠습니다.

위젯츠에서는 다음과 같이 시작할 수 있을 것입니다.

당신: "누군가 비즈니스 이벤트 하나부터 붙여보죠!"

올리: "저는 주문 접수 부서의 올리입니다. 주로 들어오는 주문서랑 견적서를 처리하죠."

당신: "이런 일이 시작되는 계기는 무엇인가요?"

올리: "고객이 우리에게 우편으로 양식을 보내올 때요."

당신: "그렇다면 '주문서 접수됨', '견적서 접수됨' 같은 이벤트가 되겠군요?"

올리: "네. 그럼 그걸 벽에 붙이겠습니다."

샘: "저는 배송 부서의 샘입니다. 주문서가 승인되면 저희가 배송을 담당하죠."

당신: "그 작업을 언제 해야 하는지 어떻게 아시나요?"

샘: "주문 접수 부서로부터 주문이 넘어올 때요."

당신: "그걸 이벤트로 부른다면 뭐라고 하시겠어요?"

샘: "'주문 가능' 같은 건 어떨까요?"

올리: "우리는 완료되어 배송 준비가 된 주문을 '주문 완료(Placed order)'라고 부릅니다. 이 용어를 통일해서 쓰면 어떨까요?"

샘: "그럼 우리가 다루려는 이벤트는 '주문 완료(Order placed)'가 되겠군요?"

이런 식으로 진행됩니다. 잠시 후에는 다음과 같은 이벤트 목록이 생길 수 있습니다.

- 주문서 접수됨
- 주문 완료됨
- 주문 발송됨
- 주문 변경 요청됨
- 주문 취소 요청됨
- 반품 요청됨
- 견적서 접수됨
- 견적서 발행됨
- 신규 고객 요청 접수됨
- 신규 고객 등록됨

이 시점쯤이면 벽이 이런 식으로 꾸며져 있을 것입니다.

일부 이벤트 옆에는 '주문 접수(Place order)'나 '주문 발송(Ship order)' 같은 비즈니스 워크플로가 함께 붙어 있으며, 우리는 이제 이 이벤트들이 어떻게 연결되어 더 큰 워크플로를 이루는지 보기 시작했습니다.

전체 이벤트 스토밍 세션을 자세히 다룰 수는 없지만, 이벤트 스토밍이 요구사항 수집에 어떻게 도움이 되는지 몇 가지 측면을 살펴보겠습니다.

- 비즈니스에 대한 공유 모델

이벤트를 발견하는 것 외에도, 이벤트 스토밍의 핵심적인 장점 중 하나는 참가자 모두가 큰 벽에 붙은 같은 그림을 보며 비즈니스에 대한 공유된 이해를 쌓게 된다는 점입니다.

DDD와 마찬가지로 이벤트 스토밍은 의사소통과 공유 모델을 중시하며, '우리 대 그들'식의 사고를 피하게 합니다.

참석자들은 도메인의 낯선 측면을 배우는 것뿐 아니라, 다른 팀에 대해 갖고 있던 잘못된 가정을 깨닫거나 비즈니스 개선에 도움이 될 통찰을 얻을 수도 있습니다.

- 모든 팀에 대한 인식

가끔은 자신이 속한 업무에만 집중하다가, 다른 팀도 참여하고 있으며 자신이 만든 데이터를 필요로 할 수 있다는 사실을 잊기 쉽습니다.

하지만 모든 이해관계자가 같은 공간에 있다면, 간과되고 있던 사람들도 목소리를 낼 수 있습니다.

"저는 결제 부서의 블레이크입니다. 우리도 잊지 말아 주세요. 우리도 청구서를 발행해 회사에 돈을 벌어야 하니, 완료된 주문을 알아야 합니다. 그러니 '주문 완료(order placed)' 이벤트도 꼭 필요해요."

- 요구사항의 누락 발견

이벤트들이 벽에 타임라인 형태로 전시되면, 누락된 요구사항이 선명하게 드러나곤 합니다.

맥스: "올리, 주문 준비를 끝내면 고객에게 알려주나요? 벽에는 그런 게 안 보이네요."

올리: "아, 맞아요. 깜빡했네요. 주문이 성공적으로 완료되면 고객에게 이메일을 보내서 주문을 받았고 곧 배송할 예정이라고 알려줍니다. 그게 또 하나의 이벤트겠네요. '주문 접수 확인 이메일 발송됨'이요."

질문에 명확한 답이 없다면, 그 질문 자체를 벽에 붙여 추가 논의를 촉발해야 합니다.

또한 프로세스의 특정 부분에서 논쟁이나 의견 차이가 생긴다면, 그것을 문제로 보지 말고 기회로 보아야 합니다!

이런 부분을 깊이 파고들면 많은 것을 배우게 됩니다.

요구사항이 프로젝트 초기에 모호한 경우는 흔하기 때문에, 질문과 논의를 가시적으로 기록해두면 더 많은 작업이 필요함을 명확히 알 수 있고, 개발을 성급하게 시작하지 않도록 막아줍니다.

- 팀 간의 연결

이벤트들을 타임라인에 따라 묶으면, 한 팀의 산출물이 다른 팀의 입력이라는 사실이 자주 명확히 드러납니다.

예를 들어, 주문 접수 팀이 주문 처리를 완료하면 새로운 주문이 생성되었다는 신호를 보내야 합니다.

이 '주문 완료(Order placed)' 이벤트가 배송팀과 결제팀의 입력이 되는 것입니다.

팀들이 어떻게 기술적으로 연결되는지는 이 단계에서는 중요하지 않습니다.

우리는 메시지 큐와 데이터베이스의 장단점이 아니라, 도메인 자체에 집중해야 합니다.

- 리포팅 요구사항에 대한 인식

도메인을 이해하려고 할 때, 프로세스와 트랜잭션에만 집중하기 쉽습니다.

하지만 어떤 비즈니스든 과거에 무슨 일이 있었는지 이해해야 하며, 리포팅은 항상 도메인의 일부입니다!

이벤트 스토밍 세션에 리포팅과 UI 뷰 모델 같은 읽기 전용 모델도 반드시 포함시키세요.

### Expanding the Events to the Edges 이벤트를 경계까지 확장하기

이벤트의 흐름을 가능한 한 멀리, 시스템의 경계까지 따라가 보는 것은 종종 매우 유용합니다.

먼저, 가장 왼쪽에 있는 이벤트 이전에 어떤 이벤트가 있었는지 질문해 볼 수 있습니다.

당신: "올리, '주문서 접수됨' 이벤트는 무엇이 계기가 되나요? 어디에서 비롯되죠?"

올리: "우리는 매일 아침 우편을 열고, 고객이 종이로 보낸 주문서를 열어 주문서인지 견적서인지 분류합니다."

당신: "그렇다면 '우편 도착됨'이라는 이벤트도 필요하겠군요?"

> ### Workflows, Scenarios, and Use Cases 워크플로, 시나리오, 유스케이스
> - 비즈니스 활동을 설명하는 데는 '워크플로', '시나리오', '유스케이스', '프로세스' 등 다양한 용어가 사용됩니다.
> - 이 용어들은 종종 혼용되지만, 이 책에서는 좀 더 명확히 구분해 사용하겠습니다.
>   - 시나리오는 고객(또는 다른 사용자)이 달성하고자 하는 목표를 설명하는 것으로, 예를 들어 주문하기 같은 것을 말합니다.
>     이는 애자일 개발에서 말하는 '스토리'와 유사합니다.
>     유스케이스는 시나리오를 좀 더 구체화한 것으로, 사용자가 목표를 달성하기 위해 거쳐야 하는 상호작용과 단계를 전반적으로 서술합니다.
>     시나리오와 유스케이스는 모두 사용자 관점에서 상호작용이 어떻게 보이는지에 초점을 둔 사용자 중심 개념입니다.
>   - 비즈니스 프로세스는 개별 사용자가 아닌 비즈니스 전체가 달성하고자 하는 목표를 설명합니다.
>     이는 시나리오와 비슷하지만, 사용자 중심이 아니라 비즈니스 중심의 시각을 가집니다.
>   - 워크플로는 비즈니스 프로세스의 일부를 구체적으로 설명한 것입니다.
>     즉, 직원(또는 소프트웨어 구성 요소)이 비즈니스 목표나 하위 목표를 달성하기 위해 수행해야 하는 구체적인 단계들을 나열합니다.
>     워크플로는 한 사람 또는 한 팀이 수행할 수 있는 범위로 한정할 것입니다. 이렇게 하면 주문 처리처럼 여러 팀에 걸친 비즈니스 프로세스도 일련의 작은 워크플로로 나누고, 이들을 어떤 방식으로든 조율할 수 있습니다.

마찬가지로, 비즈니스의 배송 측면에서도 이벤트를 확장할 수 있습니다.

당신: "샘, 고객에게 주문을 발송한 후에 발생할 수 있는 이벤트가 있을까요?"

샘: "네, 주문이 '수령 서명됨(Signed for delivery)' 상태가 되면 택배사로부터 알림을 받습니다. 그러니 '고객이 배송품 수령함(Shipment received by customer)'이라는 이벤트를 추가하겠습니다."

이벤트를 양쪽으로 가능한 한 멀리 확장해보는 것은 누락된 요구사항을 발견하는 훌륭한 방법입니다.

이벤트 체인이 예상보다 훨씬 길어질 수도 있습니다.

도메인 전문가가 종이 양식과 우편물에 대해 이야기하고 있다는 점에 주목하세요.

우리가 구축하려는 시스템은 전산화된 것이지만, 워크플로, 우선순위, 예외 처리 등의 측면에서 종이 기반 시스템을 생각해보면 많은 것을 배울 수 있습니다.

지금은 도메인 자체를 이해하는 데 집중합시다. 충분히 이해한 후에야 이를 디지털로 구현하는 방법을 고민해야 합니다.

실제로 많은 비즈니스 프로세스에서는 종이냐 디지털이냐의 구분이 중요하지 않습니다. 도메인의 상위 개념을 이해하는 일은 특정 구현 방식에 전혀 의존하지 않기 때문입니다.

회계 도메인이 좋은 예입니다. 이 분야의 개념과 용어는 수백 년 동안 변하지 않았습니다.

또한 종이 기반 시스템을 전산 시스템으로 전환할 때는, 모든 것을 한 번에 바꿀 필요가 없는 경우가 많습니다.

시스템을 전체적으로 살펴보고, 가장 이득이 큰 부분부터 점진적으로 전환해 나가는 것이 좋습니다.

### Documenting Commands 명령 문서화하기

이벤트를 여러 개 벽에 붙이고 나면, 우리는 "이 도메인 이벤트들은 무엇 때문에 발생했을까?"라고 물을 수 있습니다.

누군가 어떤 활동이 일어나기를 원했기 때문입니다.

예를 들어, 고객이 주문서를 보내기를 원했거나, 상사가 어떤 일을 해달라고 요청했을 수 있습니다.

DDD 용어로는 이러한 요청을 '명령(Command)'이라고 부릅니다. (객체지향 프로그래밍에서 사용하는 커맨드 패턴과 혼동하지 마세요.)

명령은 항상 "이걸 해라"와 같은 명령형으로 작성됩니다.

물론 모든 명령이 실제로 성공하는 것은 아닙니다. 주문서가 우편에서 분실될 수도 있고, 당신이 더 중요한 일 때문에 상사의 요청을 처리하지 못할 수도 있습니다.

하지만 명령이 성공하면, 그 명령은 워크플로를 시작하고, 그 결과로 도메인 이벤트가 발생합니다.

다음은 몇 가지 예시입니다.

- 명령이 "X를 발생시켜라"였다면, 워크플로가 실제로 X를 발생시켰을 때 도메인 이벤트는 "X 발생함"이 됩니다.

- 명령이 "위젯츠사에 주문서를 보내라"였다면, 워크플로가 주문서를 보냈을 때 도메인 이벤트는 "주문서 전송됨"이 됩니다.

- 명령: "주문 접수하라" → 도메인 이벤트: "주문 접수됨"

- 명령: "ABC 고객에게 배송하라" → 도메인 이벤트: "배송됨"

사실 대부분의 비즈니스 프로세스를 우리는 이런 방식으로 모델링할 것입니다.

이벤트가 명령을 유발하고, 명령은 어떤 비즈니스 워크플로를 시작합니다.

워크플로의 출력은 새로운 이벤트들입니다.

그리고 물론, 그 이벤트들이 다시 새로운 명령을 유발할 수 있습니다.

비즈니스 프로세스를 입력과 출력이 있는 파이프라인으로 생각하는 방식은, 나중에 살펴보겠지만 함수형 프로그래밍의 사고방식과 매우 잘 맞아떨어집니다.

이 접근법을 사용하면, 주문 접수 프로세스는 다음과 같이 보입니다.

지금은 모든 명령이 성공하고 그에 해당하는 이벤트가 발생한다고 가정하겠습니다.

나중에 10장에서 '구현: 오류 처리' 부분에서, 명령이 실패하거나 잘못된 경우를 어떻게 모델링하고 처리하는지 살펴볼 것입니다.

참고로 모든 이벤트가 반드시 명령과 연결될 필요는 없습니다.

일부 이벤트는 회계 시스템의 '월말 마감(MonthEndClose)'이나 창고 시스템의 '품절(OutOfStock)'처럼 스케줄러나 모니터링 시스템에 의해 촉발될 수도 있습니다.

## Partitioning the Domain into Subdomains 도메인을 하위 도메인으로 분할하기

우리는 이제 여러 이벤트와 명령 목록을 확보했고, 다양한 비즈니스 프로세스가 무엇인지도 잘 이해하게 되었습니다.

하지만 전체 그림은 여전히 상당히 혼란스럽습니다. 코드를 작성하기 전에 이 복잡함을 정리해야 합니다.

이제 두 번째 지침으로 넘어갑니다. "문제 도메인을 더 작은 하위 도메인으로 분할하라."

큰 문제에 직면했을 때, 그것을 별도로 다룰 수 있는 더 작은 구성 요소로 나누는 것은 자연스러운 일입니다. 여기서도 마찬가지입니다.

우리는 '주문 접수 관련 이벤트들을 정리한다'는 큰 문제를 안고 있습니다. 이것을 더 작은 단위로 나눌 수 있을까요? 물론 가능합니다.

'주문 접수 프로세스'의 여러 측면 --- 주문 접수, 배송, 결제 등 --- 은 분리할 수 있음이 명확합니다.

비즈니스 조직상에서도 이미 이 영역들이 별도 부서로 나뉘어 있다는 사실은, 설계에서도 동일하게 나눌 수 있다는 강력한 힌트입니다.

이제 우리는 이 각각의 영역을 '도메인(domain)'이라고 부를 것입니다.

물론 '도메인'이라는 단어는 여러 뜻을 갖고 있지만, 도메인 주도 설계(DDD)에서 말하는 도메인은 '일관된 지식의 영역'으로 정의할 수 있습니다.

하지만 이 정의만으로는 너무 모호해서 실용성이 떨어지므로, 좀 더 실용적인 정의를 사용하겠습니다. "도메인"이란 곧 "도메인 전문가가 전문성을 가진
영역"입니다!

이 정의가 훨씬 실용적입니다. 예를 들어 '결제(billing)'가 사전적으로 무엇인지 설명하려 애쓰기보다는, 결제 부서 사람들(도메인 전문가)이 하는 일이 곧 '결제'라고 말할 수 있습니다.

우리는 모두 '도메인 전문가'가 무엇인지 알고 있습니다. 사실 프로그래머인 우리 자신도 여러 도메인에 대한 전문가이기도 합니다.

예를 들어, 특정 프로그래밍 언어나 게임·과학 프로그래밍 같은 특정 분야의 전문가일 수 있습니다.

또는 보안, 네트워킹, 저수준 최적화 같은 분야에 대한 지식을 가지고 있을 수도 있습니다.

이 모든 것들이 '도메인'입니다.

도메인 안에는 서로 구별되는 하위 영역들이 존재할 수 있습니다.

우리는 이를 '하위 도메인(subdomain)'이라 부릅니다. 하위 도메인은 더 큰 도메인의 일부이면서도 고유한 전문 지식을 지닙니다.

예를 들어, '웹 프로그래밍'은 '일반 프로그래밍'의 하위 도메인입니다.

그리고 '자바스크립트 프로그래밍'은 웹 프로그래밍의 하위 도메인입니다(적어도 과거에는 그랬습니다).

아래는 프로그래밍 관련 도메인들을 보여주는 다이어그램입니다.

도메인들은 서로 겹칠 수 있다는 것을 알 수 있습니다.

예를 들어, 'CSS' 하위 도메인은 '웹 프로그래밍' 도메인의 일부일 수도 있고, 동시에 '웹 디자인' 도메인의 일부로도 볼 수 있습니다.

따라서 도메인을 더 작은 부분으로 분할할 때에는 주의해야 합니다. 명확하고 깔끔한 경계를 그리고 싶어지지만, 현실 세계는 그보다 훨씬 더 모호하기
때문입니다.

이 도메인 분할 접근법을 주문 접수 시스템에 적용하면 다음과 같은 형태가 됩니다.

각 도메인들은 서로 약간씩 겹칩니다.

주문 접수 담당자는 결제 및 배송 부서의 업무를 조금은 알아야 하고, 배송 담당자는 주문 접수 및 결제 부서의 업무를 조금은 알아야 하는 식입니다.

앞서 강조했듯이, 효과적으로 해결책을 개발하려면 개발자 스스로도 어느 정도 도메인 전문가가 되어야 합니다.

즉, 개발자인 우리는 지금까지보다 더 깊이 위 도메인들을 이해하려는 노력이 필요합니다.

하지만 그 이야기는 잠시 미뤄두고, 이제 해결책을 만드는 데 필요한 지침들로 넘어가겠습니다.

## Creating a Solution Using Bounded Contexts 바운디드 컨텍스트를 사용해 해결책 설계하기

문제를 이해했다고 해서 해결책을 구현하는 일이 쉬운 것은 아닙니다.

해결책은 원래 도메인의 모든 정보를 담을 수 없고, 그럴 필요도 없습니다.

우리는 특정 문제를 해결하는 데 필요한 정보만 포착해야 하며, 나머지는 중요하지 않습니다.

따라서 우리는 '문제 공간'과 '해결 공간'을 구분해야 하며, 이 둘을 별개의 것으로 다루어야 합니다.

해결책을 구축하기 위해, 도메인에서 관련된 측면만 추출하여 문제 도메인 모델을 만들고 이를 해결 공간에 다시 구현해야 합니다(17쪽 그림 참조).

해결 공간에서는 문제 공간의 도메인과 하위 도메인들이 DDD 용어로 '바운디드 컨텍스트'라고 부르는 구현상의 서브시스템에 매핑됩니다.

각 바운디드 컨텍스트는 자체적으로 하나의 미니 도메인 모델입니다.

우리가 '서브시스템' 대신 '바운디드 컨텍스트'라는 용어를 쓰는 이유는,
해결책을 설계할 때 중요한 것---즉 컨텍스트와 경계를 인지하는 것---에
집중하도록 돕기 때문입니다.

왜 '컨텍스트'일까요? 각 컨텍스트는 해결 공간에서 특정한 전문 지식을
나타내기 때문입니다.

각 컨텍스트 내부에서는 공통 언어를 공유하며 설계가 일관되고 통합되어 있습니다.

하지만 현실 세계와 마찬가지로, 컨텍스트에서 벗어난 정보는 혼란스럽거나 쓸모없을 수 있습니다.

왜 '경계'일까요? 현실 세계에서 도메인은 모호한 경계를 가지지만, 소프트웨어 세계에서는 서로 다른 서브시스템 간 결합도를 줄여 독립적으로 발전하도록 만들고 싶기 때문입니다.

이를 위해 서브시스템 간 명시적인 API를 두고, 공유 코드 같은 의존성을 피하는 등의 표준적인 소프트웨어 설계 기법을 사용할 수 있습니다.

이로 인해 아쉽게도 우리의 도메인 모델은 현실 세계만큼 풍부할 수 없지만, 대신 복잡성을 줄이고 유지보수를 쉽게 할 수 있다는 장점이 있습니다.

문제 공간의 도메인이 해결 공간의 컨텍스트와 항상 일대일로 대응하는 것은 아닙니다.

여러 가지 이유로 하나의 도메인이 여러 바운디드 컨텍스트로 나뉘기도 하고, 반대로 여러 도메인이 하나의 바운디드 컨텍스트로 구현되기도 합니다.

이는 기존 레거시 시스템과 통합해야 할 때 특히 흔합니다.

예를 들어, 가상의 상황에서 위젯츠(Widgets)사가 이미 주문 접수와 결제를 하나의 시스템에서 처리하는 소프트웨어 패키지를 설치해 두었을 수 있습니다.

이 레거시 시스템과 통합해야 한다면, 비록 여러 도메인을 포괄하더라도 (18쪽 그림과 같이) 이를 하나의 바운디드 컨텍스트로 간주해야 할 것입니다.

도메인을 어떻게 분할하든, 각 바운디드 컨텍스트에 명확한 책임을 부여하는 것이 중요합니다.

왜냐하면 모델을 실제로 구현할 때, 바운디드 컨텍스트는 어떤 형태로든 소프트웨어 컴포넌트와 정확히 대응되기 때문입니다.

이 컴포넌트는 별도의 DLL로 구현될 수도 있고, 독립적인 서비스일 수도 있으며, 단순한 네임스페이스일 수도 있습니다.

구체적인 구현 방식은 지금 중요하지 않지만, 올바르게 분할하는 것은 매우 중요합니다.

### Getting the Contexts Right 바운디드 컨텍스트를 올바르게 설정하기

이러한 바운디드 컨텍스트를 정의하는 일은 겉보기엔 단순해 보이지만, 실제로는 까다로울 수 있습니다.

사실 도메인 주도 설계(DDD)에서 가장 중요한 과제 중 하나가 바로 이 컨텍스트 경계를 올바르게 설정하는 일입니다.

이 작업은 과학이라기보다 예술에 가깝지만, 도움이 될 몇 가지 지침을 소개하겠습니다.

- 도메인 전문가의 말을 경청하세요. 그들이 같은 용어를 쓰고 같은 문제에 집중한다면, 아마도 그들은 동일한 하위 도메인(즉 바운디드 컨텍스트)에 속해 있을 가능성이 높습니다.

- 기존 팀과 부서의 경계를 주의 깊게 살펴보세요. 이것은 비즈니스가 무엇을 도메인 및 하위 도메인으로 간주하는지에 대한 강력한 단서가 됩니다. 물론 항상 그런 것은 아닙니다. 같은 부서에 있어도 서로 전혀 다른 목표를 두고 일하는 경우도 있습니다. 반대로 다른 부서에 속한 사람들이 매우 긴밀히 협업한다면, 그들이 같은 도메인에서 일하고 있다는 뜻일 수도 있습니다.

- 바운디드 컨텍스트에서 '경계(boundary)'라는 부분을 잊지 마세요. 경계를 설정할 때는 범위가 점점 넓어지는 스코프 크립(Scope Creep)을 경계해야 합니다.
요구사항이 계속 바뀌는 복잡한 프로젝트에서는, 바운디드 컨텍스트의 '경계' 부분을 지키기 위해 단호할 필요가 있습니다. 너무 크거나 모호한 경계는 사실상 경계가 아닙니다. 속담에도 있듯이, "좋은 울타리가 좋은 이웃을 만든다"는 점을 기억하세요.

- 자율성을 고려한 설계를 하세요. 두 그룹이 같은 바운디드 컨텍스트를 함께 책임지게 되면, 시간이 지날수록 설계를 서로 다른 방향으로 끌고 갈 수 있습니다. 세 발 경기(두 사람이 다리를 묶고 달리는 경기)를 떠올려 보세요. 두 사람이 묶여 달리는 것보다, 각자 자유롭게 달리는 것이 훨씬 빠릅니다. 도메인 모델도 마찬가지입니다. 모든 사람을 만족시키려는 거대한 컨텍스트 하나보다, 독립적으로 발전할 수 있는 작고 자율적인 여러 바운디드 컨텍스트를 두는 것이 훨씬 낫습니다.

- 마찰 없는 비즈니스 워크플로를 위한 설계를 하세요. 하나의 워크플로가 여러 바운디드 컨텍스트와 상호작용하며 자주 지연되거나 막힌다면, 설계가 다소 '덜 예뻐지더라도' 워크플로가 원활해지도록 바운디드 컨텍스트를 리팩터링하는 것을 고려하세요. 즉, 어떤 '순수한' 설계보다도 비즈니스 및 고객 가치에 우선순위를 두어야 합니다.

마지막으로, 어떤 설계도 고정불변이 아니며, 비즈니스 요구사항이 변함에 따라 모델 역시 진화해야 합니다.

이에 대해서는 13장 '설계의 진화와 유지(Evolving a Design and Keeping It Clean)'(265쪽)에서, 주문 접수 도메인을 새로운 요구사항에 맞게 발전시키는
다양한 방법을 통해 자세히 다룰 예정입니다.

### Creating Context Maps 컨텍스트 맵 만들기

이제 이러한 컨텍스트들을 정의했다면, 설계 세부사항에 파묻히지 않고 그들 간의 상호작용, 즉 전체적인 큰 그림을 전달할 방법이 필요합니다.

DDD 용어로는 이러한 다이어그램을 '컨텍스트 맵(Context Map)'이라고 부릅니다.

여행할 때 쓰는 노선도를 떠올려 보세요. 노선도는 모든 세부 정보를 보여주지 않고, 주요 경로만 보여주어 여행 계획을 세울 수 있게 합니다.

예를 들어, 다음은 항공사 노선도의 개략도입니다.

이 다이어그램은 각 도시의 세부 정보를 보여주는 것이 아니라, 도시 간 이동 가능한 경로만 보여줍니다.

이 지도는 오직 항공편 계획을 세우는 데만 목적이 있습니다.

뉴욕을 자동차로 돌아다니려 한다면, 전혀 다른 지도(그리고 혈압약)가 필요할 것입니다.

이와 마찬가지로, 컨텍스트 맵은 여러 바운디드 컨텍스트와 그 관계를 높은 수준에서 보여줍니다.

목표는 모든 세부 정보를 담는 것이 아니라 시스템 전체의 모습을 한눈에 보여주는 것입니다.

예를 들어, 20쪽 그림처럼 지금까지 정리한 주문 접수 시스템의 전체 구도가 바로 컨텍스트 맵입니다.

이 지도를 만들 때 우리는 배송 컨텍스트의 내부 구조에는 신경 쓰지 않으며, 다만 그것이 주문 접수 컨텍스트로부터 데이터를 받는다는 사실만
중요합니다.

비공식적으로는 배송 컨텍스트를 '다운스트림', 주문 접수 컨텍스트를 '업스트림'이라고 부릅니다.

물론 두 컨텍스트는 서로 주고받는 메시지에 대해 공통 형식을 합의해야 합니다.

일반적으로 업스트림 컨텍스트가 형식에 대해 더 많은 영향력을 가집니다.

하지만 때로는 다운스트림 컨텍스트가 유연하지 않을 수도 있습니다(예: 레거시 시스템과 연동해야 하는 경우).

그럴 경우 업스트림 컨텍스트가 그 형식에 맞추거나, 중간에 변환기 역할을 하는 컴포넌트를 두어야 합니다.

(이에 대해서는 48쪽 '바운디드 컨텍스트 간 계약' 부분에서 더 자세히 다룹니다.)

마지막으로, 지금까지의 설계는 모두 하나의 지도 안에 담을 수 있다는 점을 언급할 만합니다.

더 복잡한 설계에서는 특정 하위 시스템에 집중한 여러 개의 작은 지도를 만드는 것이 자연스러운 접근입니다.

### Focusing on the Most Important Bounded Contexts 가장 중요한 바운디드 컨텍스트에 집중하기

현재까지 몇 가지 분명한 바운디드 컨텍스트를 파악했으며, 도메인 작업을 진행하다 보면 더 많은 컨텍스트를 발견할 수도 있습니다.

하지만 이 모든 컨텍스트가 똑같이 중요할까요? 개발을 시작할 때는 어떤 것에 집중해야 할까요?

일반적으로 어떤 도메인은 다른 도메인보다 더 중요합니다.

이런 도메인을 핵심 도메인(core domain)이라 하며, 비즈니스 경쟁력을 제공하고 수익을 창출하는 영역입니다.

그 외 도메인들은 필요하지만 핵심은 아닐 수 있습니다.

이들을 지원 도메인(supportive domain)이라 하며, 해당 비즈니스에만 고유하지 않다면 범용 도메인(generic domain)이라 부릅니다.

예를 들어, 위젯츠(Widgets)사에서는 뛰어난 고객 서비스가 비즈니스 경쟁력의 핵심이므로 주문 접수와 배송 도메인이 핵심 도메인일 수 있습니다.

결제 도메인은 지원 도메인으로, 실제 배송 업무는 범용 도메인으로 간주될 수 있으며, 이는 외주로 맡겨도 안전하다는 뜻입니다.

물론 현실은 그렇게 단순하지 않습니다. 때로는 핵심 도메인이 예상과 다를 수 있습니다.

예를 들어 전자상거래 기업에서는 재고를 확보하고 즉시 배송할 수 있는 능력이 고객 만족에 매우 중요하다고 판단해, 쉬운 웹사이트만큼이나 재고 관리 도메인을 핵심 도메인으로 삼을 수도 있습니다.

어떤 도메인이 가장 중요한지에 대한 합의가 없을 수도 있습니다. 각 부서가 자신들의 도메인이 가장 중요하다고 생각하기도 합니다.

또는 핵심 도메인이란 단순히 고객이 당신에게 맡기고자 하는 작업일 수도 있습니다.

하지만 어떤 경우든, 모든 바운디드 컨텍스트를 한 번에 구현하려 하지 말고 우선순위를 정하는 것이 중요합니다. 그렇게 하면 실패로 이어지기 쉽습니다.

가장 큰 가치를 더하는 바운디드 컨텍스트에 집중한 후, 그다음으로 범위를 넓혀 가는 것이 좋습니다.

## Creating a Ubiquitous Language 유비쿼터스 언어 만들기

앞서 우리는 코드와 도메인 전문가가 동일한 모델을 공유해야 한다고 말했습니다.

이는 설계 속 개념들이 도메인 전문가의 머릿속 모델에서 실제로 존재하는 것들을 표현해야 한다는 뜻입니다.

즉, 도메인 전문가가 어떤 것을 '주문(order)'이라고 부른다면, 코드 안에도 그것에 대응하며 동일한 방식으로 동작하는 `Order`라는 것이 있어야 합니다.

반대로, 도메인 전문가의 모델에 없는 개념이 설계에 등장해서는 안 됩니다.

즉, `OrderFactory`, `OrderManager`, `OrderHelper` 같은 용어를 사용해서는 안 됩니다.

도메인 전문가는 이런 단어들이 의미하는 바를 이해하지 못할 것입니다.

물론 코드베이스에는 기술적인 용어가 일부 필요하겠지만, 그것들을 설계의 일부로 드러내는 일은 피해야 합니다.

팀 전체가 공유하는 개념과 어휘를 유비쿼터스 언어(Ubiquitous Language)라고 부릅니다.

이는 비즈니스 도메인에 대한 공유된 정신적 모델을 정의하는 언어입니다.

이 언어는 이름 그대로 프로젝트 전반---요구사항뿐 아니라 설계, 그리고 가장 중요한 소스코드---에 걸쳐 사용되어야 합니다.

유비쿼터스 언어는 도메인 전문가가 일방적으로 정의하는 것이 아니라, 팀 전체가 함께 협력하여 만들어가는 것입니다.

또한 유비쿼터스 언어가 고정되어 있을 것이라고 기대해서도 안 됩니다. 이것은 항상 발전 중인 상태입니다.

설계가 진화함에 따라 새로운 용어나 개념을 발견할 준비를 하고, 유비쿼터스 언어도 함께 발전시켜야 합니다.

이 책의 진행 과정에서도 이러한 모습을 직접 확인하게 될 것입니다.

마지막으로, 모든 도메인과 컨텍스트를 포괄하는 단일한 유비쿼터스 언어를 가지기는 어렵다는 점을 반드시 인지해야 합니다.

각 컨텍스트는 유비쿼터스 언어의 '방언'을 가지며, 동일한 단어라도 방언마다 의미가 달라질 수 있습니다.

예를 들어, '클래스(class)'는 객체지향 프로그래밍 도메인에서는 한 가지 의미를, CSS 도메인에서는 완전히 다른 의미를 가집니다.

'Customer'나 'Product' 같은 단어를 서로 다른 컨텍스트에서 같은 의미로 강제하려고 하면, 많아야 복잡한 요구사항을, 심하면 심각한 설계 오류를 초래할 수 있습니다.

실제로 우리가 진행했던 이벤트 스토밍 세션에서도 이 문제가 드러났습니다.

모든 참석자가 이벤트를 설명할 때 '주문(order)'이라는 단어를 사용했지만,

배송 부서가 말하는 '주문'의 정의와 결제 부서가 말하는 정의가 미묘하게 다를 수 있습니다.

배송 부서는 재고 수량과 물품 개수 등에 관심이 있고, 결제 부서는 가격과 금액에 더 관심이 있기 때문입니다.

만약 맥락을 구분하지 않은 채 '주문'이라는 단어를 어디에서나 똑같이 사용한다면, 심각한 오해를 초래할 수 있습니다.

## Summarizing the Concepts of Domain-Driven Design 도메인 주도 설계 개념 요약하기

우리는 지금까지 많은 새로운 개념과 용어들을 살펴봤으므로, 다음으로 넘어가기 전에 한곳에 정리해 보겠습니다.

- 도메인이란 우리가 해결하려는 문제와 관련된 지식 영역, 혹은 간단히 말해 '도메인 전문가'가 전문성을 가진 영역입니다.
- 도메인 모델은 특정 문제와 관련된 도메인의 측면을 단순화해 표현한 것입니다. 도메인 모델은 해결 공간(solution space)에 속하고, 그것이 표현하는 도메인은 문제 공간(problem space)에 속합니다.
- 유비쿼터스 언어(Ubiquitous Language)는 도메인과 관련된 개념과 용어의 집합으로, 팀 구성원들과 소스코드 모두가 공유합니다.
- 바운디드 컨텍스트(Bounded Context)는 해결 공간에서 다른 서브시스템과 구분되는 명확한 경계를 가진 서브시스템입니다. 바운디드 컨텍스트는 문제 공간의 하위 도메인(subdomain)에 대응하는 경우가 많습니다. 또한 각 바운디드 컨텍스트는 고유한 개념과 어휘, 즉 유비쿼터스 언어의 방언을 가지고 있습니다.
- 컨텍스트 맵(Context Map)은 여러 바운디드 컨텍스트와 그 관계를 보여주는 고수준 다이어그램입니다.
- 도메인 이벤트(Domain Event)는 시스템에서 발생한 사건을 기록한 것입니다. 항상 과거 시제로 서술됩니다. 이벤트는 종종 추가적인 활동을 유발합니다.
- 명령(Command)은 어떤 프로세스가 실행되기를 요청하는 것으로, 사람이나 다른 이벤트에 의해 촉발됩니다. 프로세스가 성공하면 시스템 상태가 변경되고 하나 이상의 도메인 이벤트가 기록됩니다.

## Wrapping Up 마무리하며

이 장의 서두에서 우리는 개발팀과 도메인 전문가가 공유하는 도메인 및 해결책 모델을 만드는 것이 중요하다고 강조했습니다.

그 목표를 돕기 위한 네 가지 지침도 살펴보았습니다.

- 데이터가 아닌 이벤트와 프로세스에 집중하기
- 문제 도메인을 더 작은 하위 도메인으로 분할하기
- 해결 공간에 각 하위 도메인의 모델 만들기
- 프로젝트 참여자 모두가 공유하는 '유비쿼터스 언어' 개발하기

이제 이 지침들을 주문 접수 도메인에 어떻게 적용했는지 살펴보겠습니다.

### Events and Processes 이벤트와 프로세스

이벤트 스토밍 세션을 통해 도메인의 주요 도메인 이벤트들이 빠르게 드러났습니다.

예를 들어, 주문 접수 프로세스는 우편으로 주문서를 받으면 시작되고, 견적 처리, 신규 고객 등록 등의 워크플로도 존재한다는 것을 알게 되었습니다.

또한 주문 접수 팀이 주문 처리를 완료하면 그 이벤트가 배송팀의 배송 프로세스와 결제팀의 결제 프로세스를 시작하게 된다는 것도 배웠습니다.

더 많은 이벤트와 프로세스를 문서화할 수 있지만, 이 책에서는 우선 이 하나의 워크플로에 집중할 것입니다.

### Subdomains and Bounded Contexts 하위 도메인과 바운디드 컨텍스트

지금까지 우리는 '주문 접수', '배송', '결제'라는 세 가지 하위 도메인을 발견한 것으로 보입니다.

'도메인은 도메인 전문가가 전문성을 가진 영역'이라는 규칙을 적용해 이를 확인해봅시다.

당신: "올리, 결제 프로세스가 어떻게 진행되는지 알아요?"

올리: "조금은 아는데, 자세한 건 결제팀에 물어보는 게 좋을 것 같아요."

결제가 별도의 도메인인지 확인 완료!

이렇게 확인한 세 가지 하위 도메인에 대응하는 세 개의 바운디드 컨텍스트를 정의하고, 이들이 어떻게 상호작용하는지 보여주는 컨텍스트 맵을 만들었습니다.

이 중 어떤 것이 우리가 집중해야 할 핵심 도메인일까요?

자동화가 가장 큰 가치를 더할 수 있는 곳을 결정하려면 매니저 맥스와 논의해야겠지만, 지금은 주문 접수 도메인을 먼저 구현한다고 가정합시다.

필요하다면, 이 도메인의 산출물을 종이 문서로 변환하여 다른 팀들이 기존 프로세스를 중단 없이 이어갈 수 있게 할 수도 있습니다.

### The Ubiquitous Language 유비쿼터스 언어

지금까지는 '주문서', '견적서', '주문'과 같은 용어를 확보했으며, 설계를 구체화해가며 더 많은 용어를 발견할 것입니다.

공유된 이해를 유지하려면 이러한 용어와 정의를 정리한 실시간 문서나 위키 페이지를 만드는 것이 좋습니다.

이렇게 하면 모두가 같은 인식을 유지할 수 있고, 새 팀원들도 빠르게 적응할 수 있습니다.

### What's Next? 다음 단계

우리는 이제 문제의 개요와 해결책의 윤곽을 잡았지만, 저수준 설계를 만들거나 코딩을 시작하기 전에 여전히 해결해야 할 질문이 많습니다.

주문 처리 워크플로에서는 구체적으로 어떤 일이 벌어질까요? 입력과 출력은 무엇일까요? 이 워크플로가 상호작용하는 다른 컨텍스트가 있을까요?

배송팀이 생각하는 '주문'과 결제팀이 생각하는 '주문'은 어떻게 다를까요?

다음 장에서는 주문 접수 워크플로를 깊이 파고들며 이러한 질문에 답해보겠습니다.
